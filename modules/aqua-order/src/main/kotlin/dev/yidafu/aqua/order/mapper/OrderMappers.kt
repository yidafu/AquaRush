/*
 * AquaRush
 *
 * Copyright (C) 2025 AquaRush Team
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package dev.yidafu.aqua.order.mapper

import dev.yidafu.aqua.api.dto.CreateOrderRequest
import dev.yidafu.aqua.common.domain.model.DeliveryAddressModel
import dev.yidafu.aqua.common.domain.model.OrderModel
import dev.yidafu.aqua.common.domain.model.OrderStatus
import dev.yidafu.aqua.common.graphql.generated.OrderStatus as OrderStatusG
import dev.yidafu.aqua.common.graphql.generated.Address
import dev.yidafu.aqua.common.graphql.generated.DeliveryAddress
import dev.yidafu.aqua.common.graphql.generated.Order
import dev.yidafu.aqua.common.graphql.generated.Product
import dev.yidafu.aqua.common.graphql.generated.User
import dev.yidafu.aqua.common.id.DefaultIdGenerator
import dev.yidafu.aqua.order.dto.CreateOrderDTO
import dev.yidafu.aqua.order.dto.OrderDTO
import dev.yidafu.aqua.order.dto.UpdateOrderStatusDTO
import org.springframework.stereotype.Component
import tech.mappie.api.ObjectMappie
import tools.jackson.module.kotlin.jacksonObjectMapper
import java.time.LocalDateTime

// ============================================================================
// OrderModel ↔ OrderDTO Mappers
// ============================================================================

/**
 * Mapper for converting OrderModel to OrderDTO
 */
object OrderModelToDTOMapper : ObjectMappie<OrderModel, OrderDTO>() {
  override fun map(from: OrderModel): OrderDTO {
    val objectMapper = jacksonObjectMapper()

    return OrderDTO(
      id = from.id,
      orderNumber = from.orderNumber,
      userId = from.userId,
      productId = from.productId,
      quantity = from.quantity,
      amount = from.amountCents,
      addressId = from.addressId,
      status = from.status,
      paymentMethod = from.paymentMethod,
      paymentTransactionId = from.paymentTransactionId,
      paymentTime = from.paymentTime,
      deliveryWorkerId = from.deliveryWorkerId,
      deliveryPhotos =
        from.deliveryPhotos?.let { photos ->
          try {
            objectMapper.readValue(photos, Array<String>::class.java).toList()
          } catch (e: Exception) {
            emptyList()
          }
        },
      deliveryAddressId = from.deliveryAddressId,
      completedAt = from.completedAt,
      totalAmount = from.amountCents,
      createdAt = from.createdAt,
      updatedAt = from.updatedAt,
      // Nested objects are set to null and should be populated by the service layer
      user = null,
      product = null,
      address = null,
      deliveryWorker = null,
    )
  }
}

/**
 * Mapper for converting CreateOrderDTO to OrderModel
 */
object CreateOrderDTOToModelMapper : ObjectMappie<CreateOrderDTO, OrderModel>() {
  override fun map(from: CreateOrderDTO): OrderModel =
    OrderModel(
      id = -1L, // Will be generated by database
      orderNumber = "", // This should be generated by the service
      userId = from.userId,
      productId = from.productId,
      quantity = from.quantity,
      amountCents = from.amount,
      addressId = from.addressId,
      deliveryAddressId = from.deliveryAddressId,
      status = dev.yidafu.aqua.common.domain.model.OrderStatus.PENDING_PAYMENT,
      paymentMethod = from.paymentMethod,
      deliveryPhotos = null,
      paymentTransactionId = null,
      paymentTime = null,
      deliveryWorkerId = null,
      completedAt = null,
    )
}

/**
 * Mapper for applying UpdateOrderStatusDTO to OrderModel
 */
object UpdateOrderStatusMapper : ObjectMappie<UpdateOrderStatusDTO, OrderModel>() {
  override fun map(from: UpdateOrderStatusDTO): OrderModel {
    // This mapper is used with the existing OrderModel for updates
    // In practice, you would pass the existing model as a parameter
    // For now, this will create a new model that should be merged
    return OrderModel(
      id = -1L, // This needs to be set by the calling code
      orderNumber = "", // This needs to be set by the calling code
      userId = -1L, // This needs to be set by the calling code
      productId = -1L, // This needs to be set by the calling code
      quantity = 1, // This needs to be set by the calling code
      amountCents = 0, // This needs to be set by the calling code
      addressId = -1L, // This needs to be set by the calling code
      deliveryAddressId = -1L, // This needs to be set by the calling code
      status = from.status,
      paymentMethod = from.paymentMethod,
      deliveryPhotos =
        from.deliveryPhotos?.let { photos ->
          jacksonObjectMapper().writeValueAsString(photos)
        },
      paymentTransactionId = from.paymentTransactionId,
      paymentTime = from.paymentTime,
      deliveryWorkerId = from.deliveryWorkerId,
      completedAt = from.completedAt,
    )
  }
}

// ============================================================================
// OrderDTO ↔ GraphQL Order Mappers
// ============================================================================

/**
 * Mapper for converting OrderDTO to GraphQL Order type
 */
object OrderDTOToGraphQLMapper : ObjectMappie<OrderDTO, Order>() {
  override fun map(from: OrderDTO): Order {
    // Note: GraphQL Order constructor requires non-null nested objects
    // This mapper should only be used when nested objects are properly populated
    // Otherwise, use a service method that handles the null cases
    if (from.address == null || from.product == null || from.user == null) {
      throw IllegalArgumentException("Nested objects (address, product, user) must be populated for GraphQL conversion")
    }

    return Order(
      id = from.id,
      orderNumber = from.orderNumber,
      amount = from.amount,
      completedAt = from.completedAt,
      createdAt = from.createdAt,
      deliveryPhotos = from.deliveryPhotos,
      paymentMethod =
        from.paymentMethod
          ?.let { method ->
            dev.yidafu.aqua.common.graphql.generated.PaymentMethod
              .valueOf(method.name)
          }?.name,
      paymentTime = from.paymentTime,
      paymentTransactionId = from.paymentTransactionId,
      quantity = from.quantity,
      status =
        dev.yidafu.aqua.common.graphql.generated.OrderStatus
          .valueOf(from.status.name),
      updatedAt = from.updatedAt,
      // These are required by GraphQL Order constructor
      address = from.address!!,
      deliveryWorker = from.deliveryWorker,
      product = from.product!!,
      user = from.user!!,
    )
  }
}

/**
 * Mapper for converting GraphQL Order type to OrderDTO
 */
object GraphQLToOrderDTOMapper : ObjectMappie<Order, OrderDTO>() {
  override fun map(from: Order): OrderDTO =
    OrderDTO(
      id = from.id,
      orderNumber = from.orderNumber,
      userId = from.user.id,
      user = from.user,
      productId = from.product.id,
      product = from.product,
      quantity = from.quantity,
      amount = from.amount,
      addressId = from.address.id,
      address = from.address,
      status =
        when (from.status.name) {
          "PENDING_PAYMENT" -> dev.yidafu.aqua.common.domain.model.OrderStatus.PENDING_PAYMENT
          "PENDING_DELIVERY" -> dev.yidafu.aqua.common.domain.model.OrderStatus.PENDING_DELIVERY
          "DELIVERING" -> dev.yidafu.aqua.common.domain.model.OrderStatus.DELIVERING
          "COMPLETED" -> dev.yidafu.aqua.common.domain.model.OrderStatus.COMPLETED
          "CANCELLED" -> dev.yidafu.aqua.common.domain.model.OrderStatus.CANCELLED
          else -> dev.yidafu.aqua.common.domain.model.OrderStatus.PENDING_PAYMENT
        },
      paymentMethod =
        from.paymentMethod?.let { method ->
          when (method) {
            "WECHAT_PAY" -> dev.yidafu.aqua.common.domain.model.PaymentMethod.WECHAT_PAY
            else -> null
          }
        },
      paymentTransactionId = from.paymentTransactionId,
      paymentTime = from.paymentTime,
      deliveryWorkerId = from.deliveryWorker?.id,
      deliveryWorker = from.deliveryWorker,
      deliveryPhotos = from.deliveryPhotos?.toList(),
      deliveryAddressId = from.address.id, // Assuming delivery address is the same as user address
      completedAt = from.completedAt,
      totalAmount = from.amount, // In GraphQL, amount and totalAmount might be the same
      createdAt = from.createdAt,
      updatedAt = from.updatedAt,
    )
}

// ============================================================================
// OrderModel → GraphQL Order Direct Mapper (with placeholders)
// ============================================================================

/**
 * Simple OrderMapper that converts OrderModel to GraphQL Order
 * Note: This mapper creates placeholder objects for required nested fields
 * In a complete implementation, these should be loaded from their respective services
 */
object OrderMapper : ObjectMappie<OrderModel, Order>() {
  override fun map(from: OrderModel): Order {
    // Create placeholder objects for required nested fields
    // In a real implementation, these should be loaded from their respective services
    val placeholderUser =
      User(
        id = from.userId,
        nickname = "placeholder",
        phone = "placeholder",
        wechatOpenId = "placeholder_openid",
        avatarUrl = null,
        createdAt = from.createdAt,
        updatedAt = from.updatedAt,
      )

    val placeholderProduct =
      Product(
        id = from.productId,
        name = "placeholder",
        description = null,
        coverImageUrl = "",
        detailImages = null,
        price = from.amountCents,
        stock = 1,
        status = dev.yidafu.aqua.common.graphql.generated.ProductStatus.ONLINE,
        createdAt = from.createdAt,
        updatedAt = from.updatedAt,
      )

    val placeholderAddress =
      Address(
        id = from.addressId,
        userId = from.userId,
        province = "placeholder",
        provinceCode = null,
        city = "placeholder",
        cityCode = null,
        district = "placeholder",
        districtCode = null,
        detailAddress = "placeholder",
        isDefault = false,
        latitude = null,
        longitude = null,
        phone = "",
        receiverName = "",
        createdAt = from.createdAt,
        updatedAt = from.updatedAt,
      )

    return Order(
      id = from.id,
      orderNumber = from.orderNumber,
      amount = from.amountCents,
      completedAt = from.completedAt,
      createdAt = from.createdAt,
      deliveryPhotos =
        from.deliveryPhotos?.let { photos ->
          try {
            tools.jackson.module.kotlin
              .jacksonObjectMapper()
              .readValue(photos, Array<String>::class.java)
              .toList()
          } catch (e: Exception) {
            emptyList()
          }
        },
      paymentMethod =
        from.paymentMethod?.let { method ->
          when (method.name) {
            "WECHAT_PAY" -> "WECHAT_PAY"
            else -> method.name
          }
        },
      paymentTime = from.paymentTime,
      paymentTransactionId = from.paymentTransactionId,
      quantity = from.quantity,
      status =
        when (from.status.name) {
          "PENDING_PAYMENT" -> OrderStatusG.PENDING
          "PENDING_DELIVERY" -> OrderStatusG.PENDING
          "DELIVERING" -> OrderStatusG.OUT_FOR_DELIVERY
          "COMPLETED" -> OrderStatusG.DELIVERED
          "CANCELLED" -> OrderStatusG.CANCELLED
          else -> OrderStatusG.PENDING
        },
      updatedAt = from.updatedAt,
      address = placeholderAddress,
      deliveryWorker = null, // Optional field
      product = placeholderProduct,
      user = placeholderUser,
    )
  }
}

/**
 * Mapper for converting DeliveryAddressModel domain entity to GraphQL DeliveryAddress type
 */
object DeliveryAddressMapper : ObjectMappie<DeliveryAddressModel, DeliveryAddress>() {
  override fun map(from: DeliveryAddressModel) =
    mapping {
      to::latitude fromValue from.latitude?.toFloat()
      to::longitude fromValue from.longitude?.toFloat()
      // Most fields map automatically by name
      // Note: Mappie automatically handles Double to Float conversion for nullable fields
    }
}

/**
 * CreateOrderRequest 到 Order 的映射器
 */
@Component
object CreateOrderRequestMapper : ObjectMappie<CreateOrderRequest, OrderModel>() {
  override fun map(from: CreateOrderRequest): OrderModel {
    // 由于 Order 需要复杂的构造，我们手动创建对象
    return OrderModel(
      id = DefaultIdGenerator().generate(),
      orderNumber = from.orderNumber,
      userId = from.userId,
      productId = from.productId,
      quantity = from.quantity,
      amountCents = from.amount,
      addressId = from.addressId,
      deliveryAddressId = from.addressId, // 映射到同一字段
      status = OrderStatus.PENDING_PAYMENT,
      paymentMethod = null,
      paymentTransactionId = null,
      paymentTime = null,
      deliveryWorkerId = null,
      deliveryPhotos = null,
      completedAt = null,
      createdAt = LocalDateTime.now(),
      updatedAt = LocalDateTime.now(),
    )
  }
}
