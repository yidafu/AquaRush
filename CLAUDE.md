# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Version Requirements

**IMPORTANT**: This project uses Spring Boot 4.0.0 and requires this exact version. When resolving dependency conflicts, never downgrade Spring Boot versions as this will break the application. The project's BOM and all dependencies are configured specifically for Spring Boot 4.0.0.

## Project Overview

AquaRush is a WeChat Mini Program-based bottled water ordering and delivery management system built with a Kotlin Spring Boot 4.0.0 backend and React-based frontends. The project uses a multi-module architecture with domain-driven design principles.

## Build & Development Commands

### Backend Development

```bash
# Build all modules
./gradlew build

# Run the main application (development)
./gradlew :modules:aqua-entry:bootRun

# Build executable JAR for production
./gradlew :modules:aqua-entry:bootJar

# Run tests
./gradlew test

# Run specific module tests
./gradlew :modules:aqua-common:test
./gradlew :modules:aqua-order:test

# Update database schema (Liquibase)
./gradlew :modules:aqua-entry:update

# Ktlint code formatting
./gradlew ktlintFormat

# Ktlint code checking
./gradlew ktlintCheck

# Git commit with Angular format (when prompted "生成commit msg")
git commit -m "$(cat <<'EOF'
feat: type commit message here following Angular format

Detailed description of changes made...
EOF
)"

# Generate commit message interactively
./scripts/generate-commit.sh
```

### Frontend Development

```bash
# User Mini Program (Remax)
cd frontend/user-client
npm install --legacy-peer-deps
npm run dev

# Delivery Mini Program (Remax)
cd frontend/delivery-client
npm install --legacy-peer-deps
npm run dev

# Admin Dashboard (React + Vite)
cd frontend/admin-client
npm install
npm run dev  # Runs on http://localhost:5173
```

## Architecture Overview

### Backend Module Structure

The project follows a clean multi-module architecture where each module has a specific domain responsibility:

- **aqua-common**: Shared utilities, caching system (MapDB), GraphQL configuration, messaging infrastructure
- **aqua-api**: API interfaces and DTOs for external communication
- **aqua-logging**: Structured logging with correlation IDs and user action tracking
- **aqua-user**: User management, authentication (JWT), addresses, WeChat integration
- **aqua-product**: Product catalog and inventory management
- **aqua-order**: Order processing, domain events, and business logic
- **aqua-delivery**: Delivery worker management and task assignment
- **aqua-payment**: WeChat Pay integration and refund processing
- **aqua-statistics**: Revenue analytics and business metrics
- **aqua-storage**: File storage service for product images and delivery photos
- **aqua-notice**: WeChat notification system and template management
- **aqua-reconciliation**: Financial reconciliation with external systems
- **aqua-review**: User reviews and delivery worker ratings
- **aqua-entry**: Main Spring Boot application entry point with global configurations

### Key Design Patterns

**Event-Driven Architecture with Outbox Pattern**:
- Domain events are stored in the `events` table within the same transaction
- Scheduled polling processes events using `SELECT ... FOR UPDATE SKIP LOCKED`
- Supports multiple messaging strategies: Artemis MQ, hybrid, memory-only, or outbox-only

**Multi-Strategy Messaging**:
- High-frequency events (ORDER_PAID, PAYMENT_TIMEOUT): Memory queue for low latency
- Low-frequency events (ORDER_CREATED, ORDER_CANCELLED): Traditional outbox pattern
- Configurable batch sizes and polling intervals for different event types

**Caching System**:
- Spring Cache + MapDB integration for high-performance local caching
- Namespace-based cache isolation with configurable TTL
- Full compatibility with Spring Cache annotations (@Cacheable, @CacheEvict, @CachePut)

### Database Configuration

- **Primary Database**: PostgreSQL (configurable to MySQL)
- **Migration**: Liquibase with XML-based changelogs in `modules/aqua-entry/src/main/resources/db/changelog/`
- **Schema Management**: Automatic on startup, manual via `./gradlew :modules:aqua-entry:update`
- **ORM**: Spring Data JPA with Hibernate

### Key Database Tables

- `users`, `addresses`: User management and delivery addresses
- `products`: Product catalog with inventory tracking
- `orders`, `order_items`: Order management and line items
- `delivery_workers`, `delivery_areas`: Delivery workforce management
- `events`: Outbox pattern for event-driven architecture
- `payments`, `payment_refunds`: Financial transactions
- `reviews`, `delivery_worker_statistics`: Quality and performance tracking

### Primary Key Strategy

**IMPORTANT**: All database entities use `Long` type primary keys generated by Snowflake algorithm for distributed ID generation. This ensures:
- Unique IDs across all tables and environments
- Sortable by generation time
- High performance for distributed systems
- Avoids UUID performance overhead and storage costs

### GraphQL Schema Configuration

**IMPORTANT**: GraphQL schema files are located in `graphql-schema/schema.graphqls`. The project uses:
- `Long` types for all entity IDs (not UUID)
- Generated GraphQL types in `modules/aqua-common/src/main/graphql-gen/schema.kt`
- Schema consistency between GraphQL schema and resolver implementations
- Spring Boot auto-configuration for GraphQL endpoints at `/graphql`

### Configuration Management

Primary configuration in `modules/aqua-entry/src/main/resources/application.yml`:

- Database connection with HikariCP pooling
- WeChat Mini Program integration (app-id, app-secret)
- WeChat Pay v3 configuration with certificate management
- JWT authentication settings
- Messaging system configuration (Artemis/Memory/Outbox strategies)
- GraphQL endpoint configuration
- Jackson serialization settings

### Security Architecture

- **Authentication**: JWT tokens with configurable expiration
- **Authorization**: Role-based access control (USER, ADMIN, DELIVERY_WORKER)
- **WeChat Integration**: code2session flow for Mini Program login
- **Payment Security**: WeChat Pay v3 signature verification and certificate handling

## Frontend Architecture

### WeChat Mini Programs (Remax + React)

**User Mini Program**: Product browsing, order placement, payment, address management, order history
**Delivery Mini Program**: Task management, navigation, photo verification, status management

Both use:
- Remax framework for cross-platform Mini Program development
- TypeScript for type safety
- Axios for API communication with interceptors
- Custom TabBar icons and navigation

### Admin Dashboard (React + Vite + Ant Design)

- Modern React 18 with TypeScript
- Ant Design 5 component library
- Vite for fast development and building
- Role-based dashboard with different views for admin users
- Real-time order management and analytics

## Commit Message Generation

This project includes automated commit message generation tools to maintain consistent commit history following Angular convention.

### Available Tools

1. **Interactive Script**: `./scripts/generate-commit.sh`
   - Analyzes staged changes automatically
   - Suggests appropriate commit type and scope
   - Validates Angular commit format
   - Includes proper attribution

2. **Slash Command**: `/commit` (when available)
   - Generates commit messages based on changes
   - Follows project-specific patterns
   - Includes co-authorship information

### Commit Types Used

- `feat`: New features and functionality
- `fix`: Bug fixes and error corrections
- `docs`: Documentation and README changes
- `style`: Code formatting without logic changes
- `refactor`: Code restructuring without feature changes
- `test`: Adding or modifying tests
- `chore`: Build, dependency, or configuration changes

### Common Scopes

- `user`: User management and authentication modules
- `order`: Order processing and management
- `delivery`: Delivery worker and task management
- `product`: Product catalog and inventory
- `payment`: Payment processing and WeChat Pay integration
- `common`: Shared utilities and infrastructure
- `admin`: Admin dashboard functionality
- `schema`: Database schema and migrations
- `frontend`: Client-side applications (Mini Programs, Admin Dashboard)

### Usage Example

```bash
# Stage your changes
git add modules/aqua-user/src/main/kotlin/dev/yidafu/aqua/user/service/AuthService.kt

# Generate and create commit
./scripts/generate-commit.sh

# Or use the traditional way with template
git commit -m "$(cat <<'EOF'
feat(user): implement JWT authentication with WeChat integration

Add JWT token generation and validation with WeChat Mini Program
OAuth2 flow for secure user authentication.
EOF
)"
```

## Development Guidelines

### Module Dependencies

Modules are structured with clear dependency hierarchy:
- Domain modules (user, product, order, etc.) depend on aqua-common
- aqua-entry depends on all domain modules
- Avoid circular dependencies between business modules

### Event Processing

When adding new domain events:
1. Define event in the appropriate domain module
2. Store in events table within business transaction
3. Create event handler in the consuming module
4. Configure processing strategy in application.yml
5. Add retry logic for idempotent processing

### Cache Usage

Leverage the built-in caching system:
```kotlin
@Cacheable(value = ["orders"], key = "#orderId")
fun getOrderById(orderId: UUID): Order? {
    return orderRepository.findById(orderId).orElse(null)
}
```

Use namespaces for cache isolation and configure appropriate TTL based on data volatility.

### WeChat Integration Notes

- WeChat Mini Program login requires proper app-id and app-secret configuration
- WeChat Pay v3 needs merchant private key and platform certificate
- Template messages require pre-approved template IDs from WeChat
- All WeChat API calls should include proper error handling and retry logic

### React/TypeScript Development Requirements

**IMPORTANT**: All React components in frontend projects must use functional components with TypeScript annotations, not class components. This ensures:

- Better type safety and developer experience
- Compatibility with modern React patterns (hooks, suspense, etc.)
- Improved code maintainability and testing
- Consistency across all frontend applications

**Functional Component Pattern**:

```typescript
import React, { useState, useEffect } from 'react'

interface Props {
  title: string
  onSubmit: (data: FormData) => void
}

const MyComponent: React.FC<Props> = ({ title, onSubmit }) => {
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    // Component logic
  }, [])

  const handleSubmit = (data: FormData) => {
    setLoading(true)
    onSubmit(data)
  }

  return (
    <div>
      <h1>{title}</h1>
      {/* Component JSX */}
    </div>
  )
}

export default MyComponent
```

**Taro Page Component Pattern**:

```typescript
import React, { useState, useEffect } from 'react'
import { View, Text } from '@tarojs/components'
import Taro from '@tarojs/taro'
import {
  useReady,
  useDidShow,
  useDidHide,
  usePullDownRefresh,
  useReachBottom,
  usePageScroll,
  useShareAppMessage,
  useShareTimeline,
  useAddToFavorites,
  useTitleClick,
  useOptionMenuClick,
  useResize,
  useTabItemTap,
  useBeforeLeave,
  useSaveExitState,
  useRestoreExitState
} from '@tarojs/taro'

interface Props {
  // Page props (rarely used in Taro pages)
}

const MyPage: React.FC<Props> = () => {
  const [data, setData] = useState<any>(null)
  const [loading, setLoading] = useState<boolean>(false)

  // Standard React hooks
  useEffect(() => {
    // Component mounted logic
    console.log('Component mounted')

    return () => {
      // Cleanup logic
      console.log('Component unmounted')
    }
  }, [])

  // Taro page lifecycle hooks
  useReady(() => {
    // 对应类组件的 componentDidMount 和 componentDidReady
    console.log('Page ready')
    // 页面准备就绪时的逻辑
  })

  useDidShow(() => {
    // 对应类组件的 componentDidShow
    console.log('Page shown')
    // 页面显示时的逻辑（每次页面显示都会调用）
    loadData()
  })

  useDidHide(() => {
    // 对应类组件的 componentDidHide
    console.log('Page hidden')
    // 页面隐藏时的逻辑
  })

  usePullDownRefresh(() => {
    // 对应类组件的 onPullDownRefresh
    console.log('Pull down refresh')
    handleRefresh()
  })

  useReachBottom(() => {
    // 对应类组件的 onReachBottom
    console.log('Reach bottom')
    loadMore()
  })

  usePageScroll((event) => {
    // 对应类组件的 onPageScroll
    console.log('Page scroll:', event.scrollTop)
  })

  useShareAppMessage((res) => {
    // 对应类组件的 onShareAppMessage
    return {
      title: '分享标题',
      path: '/pages/index/index'
    }
  })

  useShareTimeline(() => {
    // 对应类组件的 onShareTimeline
    return {
      title: '朋友圈分享标题'
    }
  })

  // 自定义方法
  const loadData = async () => {
    try {
      setLoading(true)
      // 加载数据逻辑
      const result = await Taro.request({
        url: 'your-api-url',
        method: 'GET'
      })
      setData(result.data)
    } catch (error) {
      console.error('Load data failed:', error)
    } finally {
      setLoading(false)
    }
  }

  const handleRefresh = async () => {
    try {
      await loadData()
      Taro.stopPullDownRefresh()
    } catch (error) {
      console.error('Refresh failed:', error)
      Taro.stopPullDownRefresh()
    }
  }

  const loadMore = async () => {
    // 加载更多逻辑
    console.log('Loading more data...')
  }

  return (
    <View className='page'>
      {loading ? (
        <Text>加载中...</Text>
      ) : (
        <View>
          {/* 页面内容 */}
          <Text>Page Content</Text>
        </View>
      )}
    </View>
  )
}

export default MyPage
```

**TypeScript Requirements**:

- All components must have explicit `Props` interfaces
- Use `React.FC<Props>` type for functional components
- All state variables should be typed explicitly
- All functions must have parameter and return type annotations
- Use proper TypeScript event handling (e.g., `React.MouseEvent`, `React.ChangeEvent`)

### UI Design and Layout Guidelines

**IMPORTANT**: All UI components should be designed for 1x scale (实际像素尺寸) to ensure proper display and usability on devices. This ensures:

- Better readability and accessibility
- Larger touch targets for mobile users
- Improved user experience on smaller screens
- Consistent visual hierarchy across all pages

**Page Layout Standards**:

```scss
// 页面容器
.page {
  min-height: 100vh;
  padding: 60px 32px 32px; // 1x 倍尺寸，充足的间距
  box-sizing: border-box;
}

// 标题样式
.title {
  font-size: 40px; // 大标题使用 40px
  font-weight: bold;
  margin-bottom: 16px;
}

.subtitle {
  font-size: 20px; // 副标题使用 20px
  margin-bottom: 12px;
}

// 表单元素
.form-input {
  height: 64px; // 输入框高度 64px
  font-size: 20px; // 输入文字大小 20px
  padding: 16px 20px;
  border-radius: 12px;
}

.form-textarea {
  min-height: 180px; // 文本域最小高度 180px
  font-size: 20px; // 文本大小 20px
  padding: 20px;
  line-height: 1.6;
}

// 按钮样式
.primary-button {
  height: 64px; // 按钮高度 64px
  font-size: 20px; // 按钮文字大小 20px
  border-radius: 16px;
  font-weight: 600;
}

// 卡片和容器
.card {
  padding: 32px; // 卡片内边距 32px
  border-radius: 20px;
  margin-bottom: 32px;
}

// 图片上传区域
.image-upload-item {
  width: 140px; // 图片预览尺寸 140px x 140px
  height: 140px;
  border-radius: 12px;
}

// 选择器按钮
.selector-option {
  padding: 12px 24px;
  border-radius: 28px;
  font-size: 16px;
  min-height: 48px;
}
```

**Touch Target Guidelines**:

- **Minimum touch target**: 48px × 48px (符合无障碍标准)
- **Recommended button height**: 64px for primary actions
- **Input field height**: 64px for better touch accuracy
- **Icon buttons**: Minimum 32px × 32px with adequate padding

**Typography Scale**:

- **Page titles**: 40px, bold
- **Section headers**: 24px, semibold
- **Body text**: 16px, regular
- **Small text**: 14px, regular
- **Form labels**: 20px, semibold

**Spacing System**:

- **Page margins**: 32px (left/right), 60px (top)
- **Section spacing**: 32px - 48px
- **Element spacing**: 16px - 24px
- **Component padding**: 20px - 32px

**Accessibility Considerations**:

- All interactive elements must meet WCAG AA contrast standards
- Focus states should be clearly visible with 4px minimum outline
- Text should be readable at 1x scale without requiring zoom
- Touch targets should have adequate spacing between them

### Testing Strategy

- Unit tests for repositories and services
- Integration tests for controllers and event processing
- Database migrations should be tested with different database versions
- WeChat integration should be tested with sandbox environments
- React components should have unit tests with React Testing Library

## Production Deployment

### Single-Server Deployment

The project is designed for single-server deployment:
- systemd service configuration in `scripts/aquarush.service`
- Database backup scripts in `scripts/backup.sh`
- Caddy or Nginx for reverse proxy with automatic HTTPS
- Built-in monitoring via Spring Boot Actuator endpoints

### Environment Variables

Key environment variables for production:
- `DB_USERNAME`, `DB_PASSWORD`: Database credentials
- `WECHAT_APP_ID`, `WECHAT_APP_SECRET`: WeChat Mini Program credentials
- `WECHAT_PAY_MCH_ID`, `WECHAT_PAY_API_V3_KEY`: WeChat Pay credentials
- `JWT_SECRET`: JWT signing secret
- `SNOWFLAKE_MACHINE_ID`: Unique ID for distributed ID generation

## License

This project is licensed under AGPL-3.0. Any modifications must be released under the same license, and users accessing the service over network have the right to obtain the source code.
